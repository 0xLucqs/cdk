namespace cashu_sdk {};

// Cashu

[Error]
interface CashuError {
    Generic(string err);
};


// Types 


[Enum]
interface CurrencyUnit {
	Sat();
	Custom(string unit);
};

interface Bolt11Invoice {
    [Throws=CashuError]
    constructor(string bolt11);
	string as_string();
	Amount? amount();
};

interface Amount {
	u64 to_sat();	
	u64 to_msat();
	[Name = from_sat]
	constructor(u64 sat);
	[Name = from_msat]
	constructor(u64 msat);
 	sequence<Amount> split();
};


interface Secret {
	constructor();
	sequence<u8> as_bytes();	
};


interface Id {
    [Throws=CashuError]
	constructor(string id);
};

interface PublicKey {
    [Throws=CashuError, Name=from_hex]
    constructor(string hex);
    [Throws=CashuError]
    string to_hex();
};


interface SecretKey {
    [Throws=CashuError]
    string to_hex();
};

interface BlindedMessage {
	constructor(Id keyset_id, Amount amount, PublicKey b);
	Amount amount();
	PublicKey b();	
};

interface Proof {
	constructor(Amount amount, Secret secret, PublicKey c, Id id);
	Amount amount();
	Secret secret();
	PublicKey c();
	Id id();
	};

interface BlindedSignature {
	constructor(Id id, Amount amount, PublicKey c);
	Id id();
	Amount amount();
	PublicKey c();
};

interface MintProof {
	constructor(Amount? amount, Secret secret, PublicKey? c, Id? id);
	Amount? amount();
	Secret secret();
	PublicKey? c();
	Id? id();
	
};

interface MintProofs {
    [Throws=CashuError]
	constructor(string mint, sequence<Proof> proofs);
	string url();
	sequence<Proof> proofs();
};

interface Token {
    [Throws=CashuError]
	constructor(string mint, sequence<Proof> token, string? memo, CurrencyUnit? unit);
	sequence<MintProofs> token();
	string? memo();
	CurrencyUnit? unit();
	string to_string();
    [Throws=CashuError, Name=from_string]
	constructor(string token);
	
};

interface PreMintSecrets {
    [Throws=CashuError, Name=random]
	constructor(Id keyset_id, Amount amount);
    [Throws=CashuError, Name=blank]
	constructor(Id keyset_id, Amount amount);
	sequence<BlindedMessage> blinded_messages();
	sequence<Secret> secrets();
	sequence<SecretKey> rs();
	sequence<Amount> amounts();
};

interface KeyPair {
	[Name=from_secret_key]
	constructor(SecretKey secret_key);
	SecretKey secret_key();
	PublicKey public_key();	
};

interface Keys {
	constructor(record<string, PublicKey> keys);
	record<string, PublicKey> keys();
	record<string, string> as_hashmap();
	PublicKey? amount_key(Amount amount);
};

interface KeySet {
	constructor(Id id, string unit, Keys keys);
	Id id();
	Keys keys();
};


interface MintKeySet {
	[Name=generate]
	constructor(string secret, string unit, string derivation_path, u8 max_order);
};


interface KeysResponse {
	constructor(Keys keys);
};

interface KeySetResponse {
	constructor(sequence<KeySetInfo> keysets);
	sequence<KeySetInfo> keysets();
};

// NUT-05

interface MeltQuoteBolt11Response {
    [Throws=CashuError]
	constructor(string quote, u64 amount, u64 fee_reserve, boolean paid, u64 expiry);
	string quote();
	u64 amount();
	u64 fee_reserve();
	boolean paid();
	u64 expiry();
};

interface MeltQuoteBolt11Request {
    [Throws=CashuError]
	constructor(string request, string unit);
	string request();
	string unit();
};

interface MeltBolt11Request {
    [Throws=CashuError]
	constructor(sequence<Proof> inputs, string quote);
	sequence<Proof> inputs();
	string quote();
};

interface RequestMintResponse {
    [Throws=CashuError]
	constructor(string invoice, string hash);
	string invoice();
	string hash();
};

interface MintRequest {
	constructor(sequence<BlindedMessage> outputs);
	sequence<BlindedMessage> outputs();
	Amount total_amount();
};

interface PostMintResponse {
	constructor(sequence<BlindedSignature> promises);
	sequence<BlindedSignature> promises();
};

interface SplitRequest {
	constructor(sequence<Proof> proofs, sequence<BlindedMessage> outputs);
	sequence<Proof> proofs();
	sequence<BlindedMessage> outputs();
	Amount proofs_amount();
	Amount output_amount();
};

interface SplitResponse {
	constructor(sequence<BlindedSignature> promises);
	sequence<BlindedSignature> promises();
	Amount? promises_amount();

};


interface MintVersion {
	constructor(string name, string version);
	string name();
	string version();
};

interface MintInfo {
	constructor(string? name, PublicKey? pubkey, MintVersion? version, string? description, string? description_long, sequence<sequence<string>>? contact, sequence<string> nuts, string? motd);
	string? name();
	PublicKey? pubkey();
	MintVersion? version();
	string? description();
	string? description_long();
	sequence<sequence<string>>? contact();
	sequence<string> nuts();
	string? motd();
};

enum InvoiceStatus {
	"Unpaid",
	"Paid",
	"Expired",
	"InFlight"
};

interface ProofsStatus {
	constructor(sequence<Proof> spendable, sequence<Proof> spent);
	sequence<Proof> spendable();
	sequence<Proof> spent();
};


interface KeySetInfo {
	constructor(Id id, string unit);
	
};

// Cashu Sdk

interface MintKeySetInfo {
	constructor(Id id, boolean active, string unit, u64 valid_from, u64? valid_to, string derivation_path, u8 max_order);
};


[Error]
interface CashuSdkError {
    Generic(string err);
};

interface SendProofs {
	constructor(sequence<Proof> change_proofs, sequence<Proof> send_proofs);
	sequence<Proof> send_proofs();
	sequence<Proof> change_proofs();
};

interface Melted {
	constructor(boolean paid, string? preimage, sequence<Proof>? change);
	string? preimage();
	boolean paid();
	sequence<Proof>? change();
};

interface Wallet {
	// [Throws=CashuSdkError]
	// ProofsStatus check_proofs_spent(sequence<Proof> proofs);
    [Throws=CashuSdkError]
	RequestMintResponse request_mint(Amount amount);
    [Throws=CashuSdkError]
	Token mint_token(Amount amount, string hash, string? unit, string? memo);
    [Throws=CashuSdkError]
	sequence<Proof> mint(Amount amount, string hash);
    [Throws=CashuSdkError]
	Amount check_fee(Bolt11Invoice invoice);
    [Throws=CashuSdkError]
	sequence<Proof> receive(string encoded_token);
    [Throws=CashuSdkError]
	sequence<Proof> process_split_response(PreMintSecrets blinded_messages, sequence<BlindedSignature> promises);
    [Throws=CashuSdkError]
	SendProofs send(Amount amount, sequence<Proof> proofs);
    [Throws=CashuSdkError]
	Melted melt(Bolt11Invoice invoice, sequence<Proof> proofs, Amount fee_reserve);
    [Throws=CashuSdkError]
	string proof_to_token(sequence<Proof> proof, string? unit, string? memo);
};


interface Mint {
    [Throws=CashuSdkError]
	constructor(string secret, sequence<MintKeySetInfo> keysets_info, sequence<Secret> spent_secrets, Amount min_fee_reserve, f32 percent_fee_reserve);
	KeysResponse? keyset_pubkeys(Id keyset_id);
	KeySetResponse keysets();
	KeySet? keyset(Id id);
    [Throws=CashuSdkError]
	PostMintResponse process_mint_request(MintRequest mint_request);
    [Throws=CashuSdkError]
	SplitResponse process_split_request(SplitRequest split_request);
    [Throws=CashuSdkError]
	void verify_melt_request(MeltRequest melt_request);
    [Throws=CashuSdkError]
	MeltResponse process_melt_request(MeltRequest melt_request, string preimage, Amount totoal_spent);
};
